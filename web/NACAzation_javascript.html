<!--
Group 6 final project: NACAzation

Simone Cimolato, Thomas Reilly
-->

<!DOCTYPE html>
<html>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<head>
		<title>NACAzation</title>
		<style>
			#CX {
				font-size: 26px; 	/* Adjust the font size as needed */
				color: #333; 	   /* Set the text color */
				font-family: 'Arial', sans-serif; /* Set the font family */
				margin-top: 10px;   /* Add some top margin for spacing */
				margin-right: 60px; /* Add some top margin for spacing */
				float: right;
			}

			.button-container {
				width: 50%;
				float:left;
				margin-top: 1%;
			}

			input[type="radio"] {
				display: none;
			}

			label {
				cursor: pointer;
				padding: 8px 16px;
				border: 1px solid #ccc;
				margin-right: 5px;
				font-family: 'Arial', sans-serif;
				border-radius: 10px; /* Rounded corners */
			}

			input[type="radio"]:checked + label {
				background-color: #3498db;
				color: #fff;
			}
			
			#pauseStep {
				float: right;
				margin-right: 18.5%;
				margin-top: 1%;
			}	
		</style>
	</head>
<body>
	<canvas id="myCanvas" style="border:2px solid"></canvas>
	<div id = "CX">
	</div>
	<script>
		/*
		Assumptions: 
			- incompressible fluid
			- inviscid fluid

		Features:
			- staggered grid (velcity field values u and v stored on grid edges)
			- 2 steps:
				1 applying incompressibility (projection)
					- setting fluid divergence from each cell at 0:
						- computing divergence d at each cell (in general not always = 0)
						- carefully adding/subtracting d/4 from each velocity at each edge so that the new divergence will be 0
						- velocities on walls/obstacles are set to be 0, the divergence is divided by the number of the remaining "free" velocities and subracted/added to them
					- computing pressure in each cell using overrelaxation
					- computing aerodynamic force by integrating pressure of the obstacle's surface, computing CL and CD
				1 move the velocity field and density (semi-lagrangian advection)

		TODO:
			- implement airfoils
			- input interface for airfoil generation
			- print on screen of drag/lift and CD/CL
		*/

		var canvas = document.getElementById("myCanvas");
		var c = canvas.getContext("2d");	
		canvas.width = window.innerWidth * 0.8;
		canvas.height = window.innerHeight * 0.9;

		canvas.focus();

		var simHeight = 1.01;	
		var cScale = canvas.height / simHeight;
		var simWidth = canvas.width / cScale;

		var U_FIELD = 0;
		var V_FIELD = 1;
		var S_FIELD = 2;

		var scene = {
			paused: false,
			showObstacle: true,
			showPressure: false,
			showSpeed: true,
			showCurl: false,
			fluid: null,
			obstacleRadius: 0.10,
			setObstacleX: 0.5,
			setObstacleY: 0.4,
			overRelaxation: 1.9, // should be between 1 and 2
			dt: 1.0 / 60.0,
			numIters: 50,
			res: 105, // default is 100
			domainHeight: 1,
			cx: [],
			interval: 25,
		};

		class Fluid {
			constructor(density, numX, numY, h) {
				this.density = density;
				this.numX = numX + 3; 
				this.numY = numY + 3;
				this.numCells = this.numX * this.numY;
				this.h = h;									 // grid spacing
				this.u = new Float32Array(this.numCells);	 // horizontal velocity
				this.v = new Float32Array(this.numCells);	 // vertical velocity
				this.newU = new Float32Array(this.numCells);
				this.newV = new Float32Array(this.numCells);
				this.p = new Float32Array(this.numCells);	 // pressure
				this.s = new Float32Array(this.numCells);	 // keeps track of whether a cell is fluid (s_ij = 1) or wall/obstacle (s_ij = 0)
				this.m = new Float32Array(this.numCells);	 // object position
				this.newM = new Float32Array(this.numCells);
				this.curl = new Float32Array(this.numCells); // curl
				this.force = 0;								 // force exerted on the body by the fluid
				this.m.fill(0);
				this.p.fill(0.0);
				this.curl.fill(0.0);
				var num = numX * numY;
			}

			solveIncompressibility(numIters, dt) {
				var n = this.numY;
				var cp = this.density * this.h / dt;

				for (var iter = 0; iter < numIters; iter++) {
					for (var i = 1; i < this.numX-1; i++) {
						for (var j = 1; j < this.numY-1; j++) {
							if (this.s[i*n + j] == 0.0)
								continue;

							var s = this.s[i*n + j];
							var sx0 = this.s[(i-1)*n + j];
							var sx1 = this.s[(i+1)*n + j];
							var sy0 = this.s[i*n + j-1];
							var sy1 = this.s[i*n + j+1];
							var s = sx0 + sx1 + sy0 + sy1;

							if (s == 0.0)
								continue;

							// divergence
							var div = this.u[(i+1)*n + j] - this.u[i*n + j] + this.v[i*n + j+1] - this.v[i*n + j];

							// computing pressure
							var p = -div / s;
							p *= scene.overRelaxation;
							this.p[i*n + j] += cp * p; 
							
							this.u[i*n + j] -= sx0 * p;
							this.u[(i+1)*n + j] += sx1 * p;
							this.v[i*n + j] -= sy0 * p;
							this.v[i*n + j+1] += sy1 * p;
						}
					}
				}

				// calculating the pressure
				this.force = 0;
				for (var i = 1; i < this.numX-1; i++) {
					for (var j = 1; j < this.numY-1; j++) {
						if (this.s[i*n + j] == 0.0)
							continue;

						var s = this.s[i*n + j];
						var sx0 = this.s[(i-1)*n + j];
						var sx1 = this.s[(i+1)*n + j];
						var sy0 = this.s[i*n + j-1];
						var sy1 = this.s[i*n + j+1];
						var s = sx0 + sx1 + sy0 + sy1;

						if (s == 0.0)
								continue;

						if (s < 4 && i > 5 && i <this.numX-15 && j>5 && j <this.numY-15){ // temporary condition
							this.force += this.p[i*n + j];
						}
					}
				}
				// CD & CL calculation and printing
				scene.cx.push(Math.abs(2 * this.force / (this.density * scene.inVel * scene.inVel * 2 * scene.obstacleRadius))); // this shit is wrong, should be 100x less
				if(scene.cx.length % scene.interval == 0){
					// average of the last scene.interval elements
					document.getElementById("CX").innerHTML = "CX: " + mean(scene.cx.slice(scene.cx.length - scene.interval)).toFixed(4);
				}
			}
			
			extrapolate() {
				var n = this.numY;
				for (var i = 0; i < this.numX; i++) {
					this.u[i*n] = this.u[i*n + 1];
					this.u[i*n + this.numY-1] = this.u[i*n + this.numY-2]; 
				}
				for (var j = 0; j < this.numY; j++) {
					this.v[j] = this.v[n + j];
					this.v[(this.numX-1)*n + j] = this.v[(this.numX-2)*n + j] 
				}
			}

			sampleField(x, y, field) {
				var n = this.numY;
				var h = this.h;
				var h1 = 1 / h;
				var h2 = 0.55 * h;

				x = Math.max(Math.min(x, this.numX * h), h);
				y = Math.max(Math.min(y, this.numY * h), h);

				var dx = 0.0;
				var dy = 0.0;

				var f;

				switch (field) {
					case U_FIELD: f = this.u; 
						dy = h2; 
						break;
					case V_FIELD: f = this.v; 
						dx = h2; 
						break;
					case S_FIELD: f = this.m; 
						dx = h2; 
						dy = h2; 
						break
				}

				var x0 = Math.min(Math.floor((x-dx)*h1), this.numX-1);
				var tx = ((x-dx) - x0*h) * h1;
				var x1 = Math.min(x0 + 1, this.numX-1);
				
				var y0 = Math.min(Math.floor((y-dy)*h1), this.numY-1);
				var ty = ((y-dy) - y0*h) * h1;
				var y1 = Math.min(y0 + 1, this.numY-1);

				var sx = 1.0 - tx;
				var sy = 1.0 - ty;

				var val = sx*sy * f[x0*n + y0] +
					tx*sy * f[x1*n + y0] +
					tx*ty * f[x1*n + y1] +
					sx*ty * f[x0*n + y1];
				return val;
			}

			avgU(i, j) {
				var n = this.numY;
				var u = (this.u[i*n + j-1] + this.u[i*n + j] + this.u[(i+1)*n + j-1] + this.u[(i+1)*n + j]) * 0.25;
				return u;
			}

			avgV(i, j) {
				var n = this.numY;
				var v = (this.v[(i-1)*n + j] + this.v[i*n + j] + this.v[(i-1)*n + j+1] + this.v[i*n + j+1]) * 0.25;
				return v;
			}

			advectVel(dt) {
				this.newU.set(this.u);
				this.newV.set(this.v);

				var n = this.numY;
				var h = this.h;
				var h2 = 0.5 * h;

				for (var i = 1; i < this.numX; i++) {
					for (var j = 1; j < this.numY; j++) {

						// u component
						if (this.s[i*n + j] != 0.0 && this.s[(i-1)*n + j] != 0.0 && j < this.numY - 1) {
							var x = i*h;
							var y = j*h + h2;
							var u = this.u[i*n + j];
							var v = this.avgV(i, j);

							x = x - dt*u;
							y = y - dt*v;
							u = this.sampleField(x,y, U_FIELD);
							this.newU[i*n + j] = u;
						}

						// v component
						if (this.s[i*n + j] != 0.0 && this.s[i*n + j-1] != 0.0 && i < this.numX - 1) {
							var x = i*h + h2;
							var y = j*h;
							var u = this.avgU(i, j);

							var v = this.v[i*n + j];
							x = x - dt*u;
							y = y - dt*v;
							v = this.sampleField(x,y, V_FIELD);
							this.newV[i*n + j] = v;
						}
					}	 
				}
				this.u.set(this.newU);
				this.v.set(this.newV);
			}

			// This function is specifically designed for advecting a scalar field representing smoke density within the fluid simulation.
			advectSmoke(dt) {
				this.newM.set(this.m);

				var n = this.numY;
				var h = this.h;
				var h2 = 0.5 * h;

				for (var i = 1; i < this.numX-1; i++) {
					for (var j = 1; j < this.numY-1; j++) {

						if (this.s[i*n + j] != 0.0) {
							var u = (this.u[i*n + j] + this.u[(i+1)*n + j]) * 0.5;
							var v = (this.v[i*n + j] + this.v[i*n + j+1]) * 0.5;
							var x = i*h + h2 - dt*u;
							var y = j*h + h2 - dt*v;

							this.newM[i*n + j] = this.sampleField(x,y, S_FIELD);
						}
					}	 
				}
				this.m.set(this.newM);
			}

			simulate(dt, numIters) {
				this.p.fill(0.0);
				this.curl.fill(0.0);
				this.solveIncompressibility(numIters, dt);

				this.extrapolate();
				this.advectVel(dt);
				this.advectSmoke(dt);
			}
		}
		
		function cX(x) {
			return x * cScale;
		}

		function cY(y) {
			return canvas.height - y * cScale;
		}

		function mean(array) {
			// Check if the array is not empty
			if (array.length === 0) {
				return NaN;
			}

			// Calculate the mean using reduce
			return array.reduce((sum, currentValue) => sum + currentValue, 0) / array.length;
		}

		function calculateCurl(u, v, sizeX, sizeY) {
			f = scene.fluid;
			// Calculate the curl using finite differences
			for (let i = 1; i < sizeX - 1; i++) {
				for (let j = 1; j < sizeY - 1; j++) {
					// Calculate partial derivatives
					const du_dy = (u[(i - 1) * sizeY + j +1] - u[(i - 1) * sizeY + j -1]) / 2;
					const dv_dx = (v[(i - 1) * sizeY + j +1] - v[(i - 1) * sizeY + j -1]) / 2;

					// Calculate curl
					f.curl[(i - 1) * sizeY + j] = dv_dx - du_dy;
				}
			}
			return f.curl;
		}

		function setupScene() {
			var domainWidth = scene.domainHeight / simHeight * simWidth;
			var h = scene.domainHeight / scene.res;

			var numX = Math.floor(domainWidth / h);
			var numY = Math.floor(scene.domainHeight / h);
			density = 1;

			f = scene.fluid = new Fluid(density, numX, numY, h);
			var n = f.numY;

			// vortex shedding
			scene.inVel = 2.0;
			for (var i = 0; i < f.numX; i++) {
				for (var j = 0; j < f.numY; j++) {
					var s = 1.0;	// fluid
					if (i == 0 || j == 0 || j == f.numY-1)
						s = 0.0;	// solid
					f.s[i*n + j] = s
					f.u[i*n + j] = scene.inVel;
				}
			}

			// initializing the flow
			for (var j = 0; j < f.numY; j++)
				f.m[j] = 0;

			setObstacle(scene.setObstacleX, scene.setObstacleY, true)
		}

		// draw -------------------------------------------------------

		// inputs are values from 0 to 1 of r g and b and it returns floored 0 - 255 values
		function updateScene(option) {
			switch (option) {
				case 'speed':
					scene.showCurl = false;
					scene.showSpeed = true;
					scene.showPressure = false;
					break;
				case 'pressure':
					scene.showCurl = false;
					scene.showSpeed = false;
					scene.showPressure = true;
					break;
				case 'curl':
					scene.showCurl = true;
					scene.showSpeed = false;
					scene.showPressure = false;
					break;
				case 'pause':
					scene.paused = !scene.paused;
					break;
				case 'step':
					scene.paused = false;
					simulate();
					scene.paused = true;
					break;
				default:
					break;
			}
			updateButtonStyles();
    	}

		function updateButtonStyles() {
			const buttons = document.querySelectorAll('input[type="radio"]');
			buttons.forEach(button => {
				const label = button.nextElementSibling;
				if (button.checked) {
					label.style.backgroundColor = '#3498db';
					label.style.color = '#fff';
				} else {
					label.style.backgroundColor = '#fff';
					label.style.color = '#000';
				}
			});
		}

		function getSciColor(val, minVal, maxVal) {
			val = Math.min(Math.max(val, minVal), maxVal- 0.0001);
			var d = maxVal - minVal;
			if (d == 0.0) {
				val = 0.5;
			} else {
				val = (val - minVal) / d;
			}
			var m = 0.25;
			var num = Math.floor(val / m);
			var s = (val - num * m) / m;
			var r, g, b;

			switch(num) {
				case 0: 
					r = 0.0; 
					g = s; 
					b = 1.0; 
					break;
				case 1: 
					r = 0.0; 
					g = 1.0; 
					b = 1.0-s; 
					break;
				case 2: 
					r = s; 
					g = 1.0; 
					b = 0.0; 
					break;
				case 3: 
					r = 1.0; 
					g = 1.0 - s; 
					b = 0.0; 
					break;
			}
			if(scene.showCurl)
				return[255*r, 0*g, 255*b, 255];
			else
				return[255*r, 255*g, 255*b, 255];
		}

		function draw() {
			c.clearRect(0, 0, canvas.width, canvas.height);
			f = scene.fluid;
			n = f.numY;
			var h = f.h;

			if(scene.showCurl){
				f.curl = calculateCurl(f.u, f.v, f.numX, f.numY)
				minCurl = f.curl[0];
				maxCurl = f.curl[0];
				for (var i = 0; i < f.numCells; i++) {
					minCurl = Math.min(minCurl, f.curl[i]);
					maxCurl = Math.max(maxCurl, f.curl[i]);
				}
			} else if (scene.showPressure){
				minP = f.p[0];
				maxP = f.p[0];
				for (var i = 0; i < f.numCells; i++) {
					minP = Math.min(minP, f.p[i]);
					maxP = Math.max(maxP, f.p[i]);
				}
			} else if (scene.showSpeed){
				var maxSpeed = 0;
				for (var i = 0; i < f.numCells; i++) {
					maxSpeed = Math.max(maxSpeed, Math.sqrt(f.u[i] * f.u[i] + f.v[i] * f.v[i]));
				}
			}

			id = c.getImageData(0,0, canvas.width, canvas.height)

			var color = [255, 255, 255, 255]
			var speedShift = 1.25;

			for (var i = 0; i < f.numX; i++) {
				for (var j = 0; j < f.numY; j++) {
					if (scene.showPressure) {
						var p = f.p[i*n + j];
						var s = f.m[i*n + j];
						color = getSciColor(p, minP, maxP);
					}
					else if (scene.showCurl) {
						var curlTemp = f.curl[i*n + j];
						var s = f.m[i*n + j];
						color = getSciColor(curlTemp, minCurl, maxCurl);
					}
					else if (scene.showSpeed) {
						var speed = Math.sqrt(f.u[i*n + j] * f.u[i*n + j] + f.v[i*n + j] * f.v[i*n + j]);
						var speedNorm = speed / (speedShift * maxSpeed);
						color[0] = 255 * speedNorm;
						color[1] = 255 * speedNorm;
						color[2] = 255 * speedNorm;
					}

					var x = Math.floor(cX(i * h));
					var y = Math.floor(cY((j+1) * h));
					var cx = Math.floor(cScale * h) + 1;
					var cy = Math.floor(cScale * h) + 1;

					r = color[0];
					g = color[1];
					b = color[2];

					for (var yi = y; yi < y + cy; yi++) {
						var p = 4 * (yi * canvas.width + x)
						for (var xi = 0; xi < cx; xi++) {
							id.data[p++] = r;
							id.data[p++] = g;
							id.data[p++] = b;
							id.data[p++] = 255;
						}
					}
				}
			}

			c.putImageData(id, 0, 0);

			if (scene.showObstacle) {
				c.strokeW
				r = scene.obstacleRadius + f.h;
				if (scene.showPressure)
					c.fillStyle = "#000000";
				else
					c.fillStyle = "#DDDDDD";
				c.beginPath();	
				c.arc(cX(scene.obstacleX), cY(scene.obstacleY), cScale * r, 0.0, 2.0 * Math.PI); 
				c.closePath();
				c.fill();

				c.lineWidth = 1.0;
				c.strokeStyle = "#000000";
				c.beginPath();	
				c.arc(cX(scene.obstacleX), cY(scene.obstacleY), cScale * r, 0.0, 2.0 * Math.PI); 
				c.closePath();
				c.stroke();
				c.lineWidth = 0.5;
			}
		}

		function setObstacle(x, y, reset) {
			var vx = 0.0;
			var vy = 0.0;

			if (!reset) {
				vx = (x - scene.obstacleX) / scene.dt;
				vy = (y - scene.obstacleY) / scene.dt;
			}

			scene.obstacleX = x;
			scene.obstacleY = y;
			var r = scene.obstacleRadius;
			var f = scene.fluid;
			var n = f.numY;

			for (var i = 1; i < f.numX; i++) {
				for (var j = 1; j < f.numY-2; j++) {
					f.s[i*n + j] = 1.0;

					dx = (i + 0.5) * f.h - x;
					dy = (j + 0.5) * f.h - y;

					if (dx * dx + dy * dy < r * r) {
						f.s[i*n + j] = 0.0;
						f.m[i*n + j] = 1.0;
						f.u[i*n + j] = vx;
						f.u[(i+1)*n + j] = vx;
						f.v[i*n + j] = vy;
						f.v[i*n + j+1] = vy;
					}
				}
			}
			scene.showObstacle = true;
		}

		// main -------------------------------------------------------
		function simulate() {
			if (!scene.paused)
				scene.fluid.simulate(scene.dt, scene.numIters)
				scene.frameNr++;
		}

		function update() {
			simulate();
			draw();
			requestAnimationFrame(update);
		}
		
		setupScene();
		update();
	</script>
	<div class="button-container">
		<input type="radio" id="speed" name="visualization" onclick="updateScene('speed')" checked>
		<label for="speed">Speed</label>
	  
		<input type="radio" id="pressure" name="visualization" onclick="updateScene('pressure')">
		<label for="pressure">Pressure</label>
	  
		<input type="radio" id="curl" name="visualization" onclick="updateScene('curl')">
		<label for="curl">Curl</label>
	</div> 

	<div id="pauseStep" >
		<input type="radio" id="pause" name="super" onclick="scene.paused = !scene.paused;" checked>
		<label for="pause">Pause</label>

		<input type="radio" id="step" name="super" onclick="scene.paused = false; simulate(); scene.paused = true">
		<label for="step">Step</label>
	</div>
</body>
</html>